import{_ as d,c as p,o as a,ag as e}from"./chunks/framework.CWeRABzr.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"python/module.md","filePath":"python/module.md","lastUpdated":1740737974000}'),_={name:"python/module.md"};function n(s,t,o,i,r,l){return a(),p("div",null,t[0]||(t[0]=[e(`<p>包是一个包含多个模块的目录，目录中必须包含一个 __init__.py 文件（可以是空文件）</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>mypackage</span></span>
<span class="line"><span>    __init__.py</span></span>
<span class="line"><span>    module1.py</span></span>
<span class="line"><span>    module2.py</span></span></code></pre></div><p>每个模块都有一个 __name__ 属性：</p><p>如果模块是直接运行的，__name__ 的值为 &quot;__main__&quot;。</p><p>如果模块是被导入的，__name__ 的值为模块名。</p><p>模块的最佳实践如下</p><ul><li><p>模块命名：使用小写字母和下划线，避免与 Python 关键字冲突。</p></li><li><p>模块文档：在模块开头添加文档字符串，说明模块的功能。</p></li><li><p>避免循环导入：模块 A 导入模块 B，模块 B 又导入模块 A，会导致错误。</p></li><li><p>使用 <code>if __name__ == &quot;__main__&quot;</code>：将模块的可执行代码放在 <code>if __name__ == &quot;__main__&quot;</code> 块中。</p></li></ul><table tabindex="0"><thead><tr><th>概念</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>模块</td><td>一个 .py 文件，包含代码</td><td>mymodule.py</td></tr><tr><td>导入模块</td><td>使用 import 语句</td><td>import mymodule</td></tr><tr><td>导入部分内容</td><td>使用 from ... import ...</td><td>from mymodule import greet</td></tr><tr><td>模块别名</td><td>使用 as 关键字</td><td>import mymodule as mm</td></tr><tr><td>模块搜索路径</td><td>sys.path 查看模块搜索路径</td><td>import sys; print(sys.path)</td></tr><tr><td>标准库模块</td><td>Python 自带的模块</td><td>import math</td></tr><tr><td>第三方模块</td><td>通过 pip 安装的模块</td><td>import requests</td></tr><tr><td>包的 __init__.py</td><td>包目录中的初始化文件</td><td>mypackage/__init__.py</td></tr></tbody></table>`,8)]))}const u=d(_,[["render",n]]);export{c as __pageData,u as default};
